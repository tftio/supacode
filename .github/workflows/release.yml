name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      tag:
        required: true
        type: string

concurrency:
  group: release
  cancel-in-progress: true

jobs:
  release_notes:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
      - run: |
          TAG="$GITHUB_REF_NAME"
          if [ "$GITHUB_EVENT_NAME" = "workflow_dispatch" ]; then
            TAG="${{ inputs.tag }}"
          fi
          echo "TAG=$TAG" >> "$GITHUB_ENV"
      - name: Prepare release context
        run: |
          set -euo pipefail
          PREV_TAG=$(git tag --list 'v*' --sort=-v:refname | grep -Fvx "$TAG" | head -n 1 || true)
          if [ -n "$PREV_TAG" ]; then
            RANGE="$PREV_TAG..$TAG"
          else
            RANGE="$(git rev-list --max-parents=0 HEAD)..$TAG"
          fi
          COMMITS=$(git log --pretty=format:"%h %s" "$RANGE")
          CHANGES=$(git diff --name-status "$RANGE")
          mkdir -p build
          cat > build/release-prompt.txt <<EOF
          You are generating release notes for Supacode.
          Release tag: $TAG
          Compare range: $RANGE

          Commits:
          $COMMITS

          Files changed:
          $CHANGES

          Requirements:
          - Return JSON that matches the provided schema exactly.
          - new_features, bug_fixes, improvements are arrays of user-facing bullet text.
          - Keep each item short, concrete, and non-redundant.
          - If a section has no items, use an empty array.
          EOF
      - name: Generate release notes data
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.REVIEW_OPENAI_API_KEY }}
          prompt-file: build/release-prompt.txt
          output-schema: |
            {
              "type": "object",
              "properties": {
                "new_features": { "type": "array", "items": { "type": "string" } },
                "bug_fixes": { "type": "array", "items": { "type": "string" } },
                "improvements": { "type": "array", "items": { "type": "string" } }
              },
              "required": ["new_features", "bug_fixes", "improvements"],
              "additionalProperties": false
            }
          output-file: build/release-notes.json
      - name: Build release notes text
        run: |
          python3 - <<'PY'
          import json
          from pathlib import Path

          data = json.loads(Path("build/release-notes.json").read_text())
          lines = ["ðŸ“… Release date: 20 Sep 2026"]

          def add_section(title, items):
            if items:
              lines.append("")
              lines.append(title)
              lines.extend([f"- {item}" for item in items])

          add_section("âœ¨ New Features", data.get("new_features", []))
          add_section("ðŸ› Bug Fixes:", data.get("bug_fixes", []))
          add_section("ðŸŒ± Improvements:", data.get("improvements", []))

          Path("build/release-notes.txt").write_text("\n".join(lines).strip() + "\n")
          PY
      - uses: actions/upload-artifact@v4
        with:
          name: release-notes
          path: build/release-notes.txt

  build:
    runs-on: [self-hosted, macOS, ARM64]
    needs: [release_notes]
    permissions:
      contents: read
    env:
      MISE_HTTP_TIMEOUT: 120
      DEVELOPER_ID_CERT_P12: ${{ secrets.DEVELOPER_ID_CERT_P12 }}
      DEVELOPER_ID_CERT_PASSWORD: ${{ secrets.DEVELOPER_ID_CERT_PASSWORD }}
      DEVELOPER_ID_IDENTITY: ${{ secrets.DEVELOPER_ID_IDENTITY }}
      KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Mise cache
        uses: ./.github/actions/shared-cache
        with:
          path: |
            ~/.local/share/mise
            ~/.cache/mise
          key: ${{ runner.os }}-${{ runner.arch }}-mise-${{ hashFiles('mise.toml') }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-mise-
      - run: brew install mise 2>/dev/null
      - run: mise install
      - name: Ghostty cache key
        run: |
          set -euo pipefail
          GHOSTTY_SHA=$(git -C ThirdParty/ghostty rev-parse HEAD)
          printf '%s\n' "GHOSTTY_SHA=$GHOSTTY_SHA" >> "$GITHUB_ENV"
      - run: |
          TAG="$GITHUB_REF_NAME"
          if [ "$GITHUB_EVENT_NAME" = "workflow_dispatch" ]; then
            TAG="${{ inputs.tag }}"
          fi
          echo "TAG=$TAG" >> "$GITHUB_ENV"
      - run: |
          echo "$DEVELOPER_ID_CERT_P12" | base64 --decode > build-cert.p12
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security import build-cert.p12 -k build.keychain -P "$DEVELOPER_ID_CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/xcodebuild
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" build.keychain
          security list-keychains -d user -s build.keychain $(security list-keychains -d user | tr -d '"')
          security default-keychain -s build.keychain
          security find-identity -v -p codesigning build.keychain
          DEVELOPER_ID_IDENTITY_SHA=$(security find-identity -v -p codesigning build.keychain | rg "Developer ID Application" | head -1 | awk '{print $2}')
          if [ -z "$DEVELOPER_ID_IDENTITY_SHA" ]; then
            echo "::error::Developer ID Application identity not found in keychain"
            exit 1
          fi
          echo "DEVELOPER_ID_IDENTITY_SHA=$DEVELOPER_ID_IDENTITY_SHA" >> "$GITHUB_ENV"
      - name: Ghostty cache
        uses: ./.github/actions/shared-cache
        with:
          path: |
            Frameworks/GhosttyKit.xcframework
            Resources/ghostty
            Resources/terminfo
          key: ${{ runner.os }}-${{ runner.arch }}-ghostty-${{ env.GHOSTTY_SHA }}
      - name: Build ghostty
        run: |
          set -euo pipefail
          make build-ghostty-xcframework
      - name: Archive Xcode project
        run: |
          set -o pipefail
          xcodebuild -project supacode.xcodeproj -scheme supacode -configuration Release -archivePath build/supacode.xcarchive archive CODE_SIGN_STYLE=Manual DEVELOPMENT_TEAM="$APPLE_TEAM_ID" CODE_SIGN_IDENTITY="$DEVELOPER_ID_IDENTITY_SHA" OTHER_CODE_SIGN_FLAGS="--timestamp" -skipMacroValidation 2>&1 | mise exec -- xcsift -qw --format toon
      - name: Upload dSYMs to Sentry
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: supabit
          SENTRY_PROJECT: supacode
        run: |
          mise exec -- sentry-cli debug-files upload --include-sources build/supacode.xcarchive/dSYMs
      - run: |
          cat > build/ExportOptions.plist <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key>
            <string>developer-id</string>
            <key>signingStyle</key>
            <string>manual</string>
            <key>signingCertificate</key>
          <string>$DEVELOPER_ID_IDENTITY</string>
            <key>teamID</key>
            <string>$APPLE_TEAM_ID</string>
          </dict>
          </plist>
          EOF
          set -o pipefail
          xcodebuild -exportArchive -archivePath build/supacode.xcarchive -exportPath build/export -exportOptionsPlist build/ExportOptions.plist 2>&1 | mise exec -- xcsift -qw --format toon
      - name: Re-sign Sparkle framework
        run: |
          set -ex
          APP_PATH="$(find build/export -name "supacode.app" -maxdepth 3 -print -quit)"
          SPARKLE="$APP_PATH/Contents/Frameworks/Sparkle.framework/Versions/B"

          echo "Using identity: $DEVELOPER_ID_IDENTITY"
          security find-identity -v -p codesigning

          codesign -f -s "$DEVELOPER_ID_IDENTITY_SHA" -o runtime --timestamp -v "$SPARKLE/XPCServices/Installer.xpc"
          codesign -f -s "$DEVELOPER_ID_IDENTITY_SHA" -o runtime --timestamp --preserve-metadata=entitlements -v "$SPARKLE/XPCServices/Downloader.xpc"
          codesign -f -s "$DEVELOPER_ID_IDENTITY_SHA" -o runtime --timestamp -v "$SPARKLE/Updater.app"
          codesign -f -s "$DEVELOPER_ID_IDENTITY_SHA" -o runtime --timestamp -v "$SPARKLE/Autoupdate"
          codesign -f -s "$DEVELOPER_ID_IDENTITY_SHA" -o runtime --timestamp -v "$SPARKLE/Sparkle"
          codesign -f -s "$DEVELOPER_ID_IDENTITY_SHA" -o runtime --timestamp -v "$APP_PATH/Contents/Frameworks/Sparkle.framework"
          codesign -f -s "$DEVELOPER_ID_IDENTITY_SHA" -o runtime --timestamp -v "$APP_PATH"

          codesign -vvv --deep --strict "$APP_PATH"
          codesign -dv --verbose=4 "$APP_PATH" 2>&1 | rg "Authority=Developer ID Application|Timestamp="
          codesign -dv --verbose=4 "$APP_PATH/Contents/MacOS/supacode" 2>&1 | rg "Authority=Developer ID Application|Timestamp="
          codesign -dv --verbose=4 "$SPARKLE/Updater.app/Contents/MacOS/Updater" 2>&1 | rg "Authority=Developer ID Application|Timestamp="
          codesign -dv --verbose=4 "$SPARKLE/XPCServices/Installer.xpc/Contents/MacOS/Installer" 2>&1 | rg "Authority=Developer ID Application|Timestamp="
          codesign -dv --verbose=4 "$SPARKLE/XPCServices/Downloader.xpc/Contents/MacOS/Downloader" 2>&1 | rg "Authority=Developer ID Application|Timestamp="
          echo "Signature verified successfully"
      - name: Notarize and staple
        run: |
          APP_PATH="$(find build/export -name "supacode.app" -maxdepth 3 -print -quit)"
          NOTARY_ZIP=build/supacode.notary.zip
          ditto -c -k --sequesterRsrc --keepParent "$APP_PATH" "$NOTARY_ZIP"

          for attempt in 1 2 3; do
            echo "Notarization attempt $attempt..."
            OUTPUT=$(xcrun notarytool submit "$NOTARY_ZIP" --apple-id "$APPLE_ID" --password "$APPLE_APP_SPECIFIC_PASSWORD" --team-id "$APPLE_TEAM_ID" --wait --output-format json 2>&1) && break
            echo "Attempt $attempt failed, retrying in 30s..."
            sleep 30
          done

          SUBMISSION_ID=$(echo "$OUTPUT" | grep -o '"id":"[^"]*"' | head -1 | cut -d'"' -f4)
          STATUS=$(echo "$OUTPUT" | grep -o '"status":"[^"]*"' | head -1 | cut -d'"' -f4)
          echo "Submission ID: $SUBMISSION_ID"
          echo "Status: $STATUS"

          if [ "$STATUS" != "Accepted" ]; then
            echo "::error::Notarization failed with status: $STATUS"
            echo "Fetching notarization log..."
            xcrun notarytool log "$SUBMISSION_ID" --apple-id "$APPLE_ID" --password "$APPLE_APP_SPECIFIC_PASSWORD" --team-id "$APPLE_TEAM_ID"
            exit 1
          fi

          xcrun stapler staple "$APP_PATH"
          ditto -c -k --sequesterRsrc --keepParent "$APP_PATH" build/supacode.app.zip
          VERSION=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$APP_PATH/Contents/Info.plist")
          echo "VERSION=$VERSION" >> "$GITHUB_ENV"
      - name: Build DMG
        run: |
          APP_PATH="$(find build/export -name "supacode.app" -maxdepth 3 -print -quit)"
          DMG_STAGE=build/dmg-stage
          DMG_NAME="supacode.dmg"
          DMG_PATH="build/$DMG_NAME"
          rm -rf "$DMG_STAGE"
          mkdir -p "$DMG_STAGE"
          cp -R "$APP_PATH" "$DMG_STAGE/"
          ln -s /Applications "$DMG_STAGE/Applications"
          hdiutil create -volname "Supacode" -srcfolder "$DMG_STAGE" -ov -format UDZO "$DMG_PATH"

          for attempt in 1 2 3; do
            echo "DMG notarization attempt $attempt..."
            OUTPUT=$(xcrun notarytool submit "$DMG_PATH" --apple-id "$APPLE_ID" --password "$APPLE_APP_SPECIFIC_PASSWORD" --team-id "$APPLE_TEAM_ID" --wait --output-format json 2>&1) && break
            echo "Attempt $attempt failed, retrying in 30s..."
            sleep 30
          done

          SUBMISSION_ID=$(echo "$OUTPUT" | grep -o '"id":"[^"]*"' | head -1 | cut -d'"' -f4)
          STATUS=$(echo "$OUTPUT" | grep -o '"status":"[^"]*"' | head -1 | cut -d'"' -f4)
          echo "Submission ID: $SUBMISSION_ID"
          echo "Status: $STATUS"

          if [ "$STATUS" != "Accepted" ]; then
            echo "::error::DMG notarization failed with status: $STATUS"
            echo "Fetching notarization log..."
            xcrun notarytool log "$SUBMISSION_ID" --apple-id "$APPLE_ID" --password "$APPLE_APP_SPECIFIC_PASSWORD" --team-id "$APPLE_TEAM_ID"
            exit 1
          fi

          xcrun stapler staple "$DMG_PATH"
          echo "DMG_PATH=$DMG_PATH" >> "$GITHUB_ENV"
      - uses: actions/download-artifact@v4
        with:
          name: release-notes
          path: build
      - run: |
          NOTES_FILE=build/release-notes.txt
          STAGING=$(mktemp -d)
          ARCHIVE=build/supacode.app.zip
          ARCHIVE_BASE=$(basename "$ARCHIVE")
          ARCHIVE_BASE="${ARCHIVE_BASE%.zip}"
          cp "$ARCHIVE" "$STAGING/"
          cp "$NOTES_FILE" "$STAGING/$ARCHIVE_BASE.txt"
          printf "%s" "$SPARKLE_PRIVATE_KEY" | tr -d '\r\n\t ' | ./bins/generate_appcast --download-url-prefix "https://supacode.sh/download/$TAG/" --embed-release-notes --ed-key-file - "$STAGING"
          cp "$STAGING/appcast.xml" build/appcast.xml
      - uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            build/supacode.app.zip
            build/supacode.dmg
            build/appcast.xml

  publish:
    runs-on: ubuntu-latest
    needs: [release_notes, build]
    permissions:
      contents: write
    env:
      GH_TOKEN: ${{ github.token }}
      RELEASE_REPO_MAIN: supabitapp/supacode
      RELEASE_REPO_SH: supabitapp/supacode-sh
      SUPACODE_SH_RELEASE_TOKEN: ${{ secrets.SUPACODE_SH_RELEASE_TOKEN }}
    steps:
      - run: |
          TAG="$GITHUB_REF_NAME"
          if [ "$GITHUB_EVENT_NAME" = "workflow_dispatch" ]; then
            TAG="${{ inputs.tag }}"
          fi
          echo "TAG=$TAG" >> "$GITHUB_ENV"
      - uses: actions/download-artifact@v4
        with:
          name: release-notes
          path: build
      - uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: build
      - run: |
          NOTES_FILE=build/release-notes.txt
          if gh release view "$TAG" -R "$RELEASE_REPO_MAIN" >/dev/null 2>&1; then
            gh release edit "$TAG" --notes-file "$NOTES_FILE" -R "$RELEASE_REPO_MAIN"
            gh release upload "$TAG" build/supacode.app.zip build/supacode.dmg build/appcast.xml --clobber -R "$RELEASE_REPO_MAIN"
          else
            gh release create "$TAG" build/supacode.app.zip build/supacode.dmg build/appcast.xml --title "$TAG" --notes-file "$NOTES_FILE" -R "$RELEASE_REPO_MAIN"
          fi

          if GH_TOKEN="$SUPACODE_SH_RELEASE_TOKEN" gh release view "$TAG" -R "$RELEASE_REPO_SH" >/dev/null 2>&1; then
            GH_TOKEN="$SUPACODE_SH_RELEASE_TOKEN" gh release edit "$TAG" --notes-file "$NOTES_FILE" -R "$RELEASE_REPO_SH"
            GH_TOKEN="$SUPACODE_SH_RELEASE_TOKEN" gh release upload "$TAG" build/supacode.app.zip build/supacode.dmg build/appcast.xml --clobber -R "$RELEASE_REPO_SH"
          else
            GH_TOKEN="$SUPACODE_SH_RELEASE_TOKEN" gh release create "$TAG" build/supacode.app.zip build/supacode.dmg build/appcast.xml --title "$TAG" --notes-file "$NOTES_FILE" -R "$RELEASE_REPO_SH"
          fi
