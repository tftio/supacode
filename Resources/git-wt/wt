#!/bin/bash
set -euo pipefail

usage() {
  cat <<'USAGE'
wt - A simple git worktree sugar

Usage:
  wt [--base-dir <dir>] <command>

Global Flags:
  --base-dir <dir>  base dir override
  -h, --help        show help

Commands:
  switch <branch> create or open a workspace
  sw <branch>     alias for switch
  exec <branch>   open a workspace and run a command
  sync [from to]  copy files between worktrees
  ls              list workspaces
  rm <branch>     remove a workspace
  here            print current workspace branch
  base            print base dir
  root            print main worktree path
  completion      print shell completion
  help [command]  show help
USAGE
}

switch_usage() {
  cat <<'USAGE'
wt switch|sw <branch>

Flags:
  --from <ref>      base ref for new branch
  --path <dir>      explicit worktree path
  --fetch           fetch remotes before resolving --from
  --init-submodules initialize submodules in new worktree
  --copy-all        copy all files to new worktree
  --copy-ignored    copy gitignored files to new worktree
  --copy-untracked  copy untracked files to new worktree
  --copy-modified   copy modified files to new worktree
  -h, --help        show help
USAGE
}

exec_usage() {
  cat <<'USAGE'
wt exec <branch> -- <cmd...>

Flags:
  --from <ref>    base ref for new branch
  --path <dir>    explicit worktree path
  --fetch         fetch remotes before resolving --from
  -h, --help      show help
USAGE
}

sync_usage() {
  cat <<'USAGE'
wt sync [<from-branch> <to-branch>]

Defaults to main worktree -> current worktree.

Flags:
  --copy-all        copy all files
  --copy-ignored    copy gitignored files
  --copy-untracked  copy untracked files
  --copy-modified   copy modified files
  -f, --force       overwrite conflicting destination files
  -n, --dry-run     show files that would be copied
  -h, --help        show help
USAGE
}

ls_usage() {
  cat <<'USAGE'
wt ls

Flags:
  --plain         tab-delimited output
  --json          JSON output
  -h, --help      show help
USAGE
}

rm_usage() {
  cat <<'USAGE'
wt rm <branch>

Flags:
  -f, --force     remove even if dirty
  -h, --help      show help
USAGE
}

here_usage() {
  cat <<'USAGE'
wt here
USAGE
}

base_usage() {
  cat <<'USAGE'
wt base
USAGE
}

root_usage() {
  cat <<'USAGE'
wt root
USAGE
}

completion_usage() {
  cat <<'USAGE'
wt completion <shell>

Shells:
  bash
  zsh
  fish
USAGE
}

die() {
  printf 'error: %s\n' "$1" >&2
  exit 1
}

BASE_DIR_OVERRIDE=""

require_repo() {
  local err
  if ! err=$(git rev-parse --git-dir 2>&1); then
    printf '%s\n' "$err" >&2
    die "not a git repository"
  fi
}

common_git_dir_abs() {
  local common
  common=$(git rev-parse --git-common-dir)
  local target
  case "$common" in
  /*) target="$common" ;;
  *) target="$(abs_path "$common")" ;;
  esac
  if [ -d "$target" ]; then
    (cd "$target" && pwd -P)
    return
  fi
  normalize_dir "$target"
}

repo_is_bare() {
  local common="${1:-}"
  if [ -z "$common" ]; then
    common=$(common_git_dir_abs)
  fi
  local is_bare
  is_bare=$(git --git-dir "$common" rev-parse --is-bare-repository)
  [ "$is_bare" = "true" ]
}

require_not_bare_for_copy() {
  if repo_is_bare; then
    die "copy flags are not supported in bare repositories"
  fi
}

main_worktree_path() {
  local common
  common=$(common_git_dir_abs)
  if repo_is_bare "$common"; then
    printf '%s\n' "$common"
    return
  fi
  while read -r key value; do
    if [ "$key" = "worktree" ]; then
      printf '%s\n' "$value"
      return
    fi
  done < <(git worktree list --porcelain)
  git rev-parse --show-toplevel
}

abs_path() {
  local path="$1"
  case "$path" in
  /*) printf '%s\n' "$path" ;;
  *) printf '%s/%s\n' "$(pwd -P)" "$path" ;;
  esac
}

normalize_dir() {
  local path="$1"
  if [ "$path" != "/" ]; then
    path="${path%/}"
  fi
  printf '%s\n' "$path"
}

base_dir() {
  local root="$1"
  local override="$2"
  local chosen
  chosen="${GIT_WT_BASE:-}"
  if [ -n "$override" ]; then
    chosen="$override"
  fi
  if [ -z "$chosen" ]; then
    normalize_dir "$(abs_path "$root/.worktrees")"
    return
  fi
  case "$chosen" in
  /*) normalize_dir "$(abs_path "$chosen")" ;;
  *) normalize_dir "$(abs_path "$root/$chosen")" ;;
  esac
}

resolve_path() {
  local root="$1"
  local path="$2"
  case "$path" in
  /*) abs_path "$path" ;;
  *) abs_path "$root/$path" ;;
  esac
}

worktree_entries() {
  local root="$1"
  local path="" head="" branch="" is_bare=0
  while IFS= read -r line || [ -n "$line" ]; do
    if [ -z "$line" ]; then
      if [ -n "$path" ]; then
        printf '%s\t%s\t%s\t%s\n' "$path" "$head" "$branch" "$is_bare"
      fi
      path=""
      head=""
      branch=""
      is_bare=0
      continue
    fi
    local key value
    key=${line%% *}
    value=${line#* }
    case "$key" in
    worktree) path="$value" ;;
    HEAD) head="$value" ;;
    branch) branch="${value#refs/heads/}" ;;
    detached) branch="" ;;
    bare) is_bare=1 ;;
    esac
  done < <(git -C "$root" worktree list --porcelain)
  if [ -n "$path" ]; then
    printf '%s\t%s\t%s\t%s\n' "$path" "$head" "$branch" "$is_bare"
  fi
}

parse_worktree_entry() {
  local entry="$1"
  local rest
  path=${entry%%$'\t'*}
  rest=${entry#*$'\t'}
  head=${rest%%$'\t'*}
  rest=${rest#*$'\t'}
  branch=${rest%%$'\t'*}
  is_bare=${rest#*$'\t'}
}

find_worktree_by_branch() {
  local root="$1"
  local target_branch="$2"
  local entry
  while IFS= read -r entry; do
    local path head branch is_bare
    parse_worktree_entry "$entry"
    if [ "$is_bare" = "1" ]; then
      continue
    fi
    if [ "$branch" = "$target_branch" ]; then
      printf '%s\n' "$path"
      return 0
    fi
  done < <(worktree_entries "$root")
  return 1
}

find_worktree_by_path() {
  local root="$1"
  local target="$2"
  local entry
  while IFS= read -r entry; do
    local path head branch is_bare
    parse_worktree_entry "$entry"
    if [ "$path" = "$target" ]; then
      printf '%s\n' "$path"
      return 0
    fi
  done < <(worktree_entries "$root")
  return 1
}

json_escape() {
  printf '%s' "$1" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g'
}

list_ignored_files() {
  local root="$1"
  git -C "$root" ls-files --others --ignored --exclude-standard | sed '/^\.git\//d'
}

list_untracked_files() {
  local root="$1"
  git -C "$root" ls-files --others --exclude-standard | sed '/^\.git\//d'
}

list_modified_files() {
  local root="$1"
  git -C "$root" ls-files --modified | sed '/^\.git\//d'
}

list_tracked_files() {
  local root="$1"
  git -C "$root" ls-files | sed '/^\.git\//d'
}

collect_copy_files() {
  local src="$1"
  local copyignored="$2"
  local copyuntracked="$3"
  local copymodified="$4"
  local copytracked="$5"
  local files=""
  if [ "$copyignored" -eq 1 ]; then
    files+=$(list_ignored_files "$src")$'\n'
  fi
  if [ "$copyuntracked" -eq 1 ]; then
    files+=$(list_untracked_files "$src")$'\n'
  fi
  if [ "$copymodified" -eq 1 ]; then
    files+=$(list_modified_files "$src")$'\n'
  fi
  if [ "$copytracked" -eq 1 ]; then
    files+=$(list_tracked_files "$src")$'\n'
  fi
  local seen="" out=""
  while IFS= read -r file; do
    [ -z "$file" ] && continue
    case "$seen" in *"$file"*) continue ;; esac
    seen+="$file"$'\n'
    out+="$file"$'\n'
  done <<< "$files"
  printf '%s' "$out"
}

copy_files_to_worktree() {
  local src="$1"
  local dst="$2"
  local copyignored="$3"
  local copyuntracked="$4"
  local copymodified="$5"
  local copytracked="$6"
  local files=""
  files=$(collect_copy_files "$src" "$copyignored" "$copyuntracked" "$copymodified" "$copytracked")
  while IFS= read -r file; do
    [ -z "$file" ] && continue
    local srcfile="$src/$file"
    local dstfile="$dst/$file"
    [ -f "$srcfile" ] || continue
    mkdir -p "$(dirname "$dstfile")"
    cp "$srcfile" "$dstfile" 2>/dev/null || true
  done <<< "$files"
}

copy_files_between() {
  local src="$1"
  local dst="$2"
  local copyignored="$3"
  local copyuntracked="$4"
  local copymodified="$5"
  local copytracked="$6"
  local force="$7"
  local dryrun="${8:-0}"
  local files=""
  files=$(collect_copy_files "$src" "$copyignored" "$copyuntracked" "$copymodified" "$copytracked")
  while IFS= read -r file; do
    [ -z "$file" ] && continue
    local srcfile="$src/$file"
    local dstfile="$dst/$file"
    [ -f "$srcfile" ] || continue
    if [ -e "$dstfile" ]; then
      if [ -d "$dstfile" ]; then
        die "destination path is a directory: '$file'"
      fi
      if cmp -s "$srcfile" "$dstfile"; then
        continue
      fi
      if git -C "$dst" ls-files --error-unmatch "$file" >/dev/null 2>&1; then
        if git -C "$dst" diff --quiet -- "$file" >/dev/null 2>&1 && git -C "$dst" diff --quiet --cached -- "$file" >/dev/null 2>&1; then
          :
        else
          if [ "$force" -eq 0 ]; then
            die "destination file has local changes: '$file'"
          fi
        fi
      else
        if [ "$force" -eq 0 ]; then
          die "destination file differs: '$file'"
        fi
      fi
    fi
    if [ "$dryrun" -eq 1 ]; then
      printf '%s\n' "$file"
    else
      mkdir -p "$(dirname "$dstfile")"
      cp "$srcfile" "$dstfile" 2>/dev/null || true
    fi
  done <<< "$files"
}

open_path() {
  local branch="$1"
  local from="$2"
  local base_override="$3"
  local path_override="$4"
  local fetch="$5"
  local initsubmodules="${6:-0}"
  local copyignored="${7:-0}"
  local copyuntracked="${8:-0}"
  local copymodified="${9:-0}"
  local copytracked="${10:-0}"
  require_repo
  if [ "$copyignored" -eq 1 ] || [ "$copyuntracked" -eq 1 ] || [ "$copymodified" -eq 1 ] || [ "$copytracked" -eq 1 ]; then
    require_not_bare_for_copy
  fi
  local root base path
  root=$(main_worktree_path)
  base=$(base_dir "$root" "$base_override")
  if [ -n "$path_override" ]; then
    path=$(resolve_path "$root" "$path_override")
  else
    path=$(resolve_path "$root" "$base/$branch")
  fi
  local existing
  if existing=$(find_worktree_by_branch "$root" "$branch"); then
    printf '%s\n' "$existing"
    return 0
  fi
  if git -C "$root" show-ref --verify --quiet "refs/heads/$branch"; then
    if [ -z "$path_override" ]; then
      die "branch exists without worktree: '$branch'"
    fi
    if find_worktree_by_path "$root" "$path" >/dev/null; then
      die "worktree path already in use: '$path'"
    fi
    mkdir -p "$(dirname "$path")"
    git -C "$root" worktree add "$path" "$branch" >/dev/null
    copy_files_to_worktree "$root" "$path" "$copyignored" "$copyuntracked" "$copymodified" "$copytracked"
    if [ "$initsubmodules" -eq 1 ]; then
      git -C "$path" submodule update --init --recursive 1>&2
    fi
    printf '%s\n' "$path"
    return 0
  fi
  if [ "$fetch" -eq 1 ]; then
    git -C "$root" fetch
  fi
  if [ -z "$from" ]; then
    from=$(git -C "$root" rev-parse HEAD)
  fi
  if ! git -C "$root" rev-parse --verify "${from}^{commit}" >/dev/null; then
    die "invalid --from ref '$from'"
  fi
  mkdir -p "$(dirname "$path")"
  git -C "$root" worktree add -b "$branch" "$path" "$from" >/dev/null
  copy_files_to_worktree "$root" "$path" "$copyignored" "$copyuntracked" "$copymodified" "$copytracked"
  if [ "$initsubmodules" -eq 1 ]; then
    git -C "$path" submodule update --init --recursive 1>&2
  fi
  printf '%s\n' "$path"
}

cmd_switch() {
  local from="" path_override="" fetch=0 branch=""
  local initsubmodules=0 copyignored=0 copyuntracked=0 copymodified=0 copytracked=0
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -h | --help)
      switch_usage
      exit 0
      ;;
    --from)
      [ -n "${2:-}" ] || die "missing value for --from"
      from="$2"
      shift
      ;;
    --from=*) from="${1#--from=}" ;;
    --path)
      [ -n "${2:-}" ] || die "missing value for --path"
      path_override="$2"
      shift
      ;;
    --path=*) path_override="${1#--path=}" ;;
    --fetch) fetch=1 ;;
    --init-submodules) initsubmodules=1 ;;
    --copy-all) copyignored=1; copyuntracked=1; copymodified=1; copytracked=1 ;;
    --copy-ignored) copyignored=1 ;;
    --copy-untracked) copyuntracked=1 ;;
    --copy-modified) copymodified=1 ;;
    --*) die "unknown flag '$1'" ;;
    *) if [ -z "$branch" ]; then branch="$1"; else die "unexpected argument '$1'"; fi ;;
    esac
    shift
  done
  [ -n "$branch" ] || die "missing branch"
  open_path "$branch" "$from" "$BASE_DIR_OVERRIDE" "$path_override" "$fetch" "$initsubmodules" "$copyignored" "$copyuntracked" "$copymodified" "$copytracked"
}

cmd_exec() {
  local from="" path_override="" fetch=0 branch=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -h | --help)
      exec_usage
      exit 0
      ;;
    --from)
      [ -n "${2:-}" ] || die "missing value for --from"
      from="$2"
      shift
      ;;
    --from=*) from="${1#--from=}" ;;
    --path)
      [ -n "${2:-}" ] || die "missing value for --path"
      path_override="$2"
      shift
      ;;
    --path=*) path_override="${1#--path=}" ;;
    --fetch) fetch=1 ;;
    --) shift; break ;;
    --*) die "unknown flag '$1'" ;;
    *)
      if [ -z "$branch" ]; then
        branch="$1"
      else
        die "missing -- before command"
      fi
      ;;
    esac
    shift
  done
  [ -n "$branch" ] || die "missing branch"
  [ "$#" -gt 0 ] || die "missing command"
  local path
  path=$(open_path "$branch" "$from" "$BASE_DIR_OVERRIDE" "$path_override" "$fetch")
  cd "$path"
  exec "$@"
}

cmd_sync() {
  local copyignored=0 copyuntracked=0 copymodified=0 copytracked=0 force=0 dryrun=0
  local from_branch="" to_branch=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -h | --help)
      sync_usage
      exit 0
      ;;
    --copy-all) copyignored=1; copyuntracked=1; copymodified=1; copytracked=1 ;;
    --copy-ignored) copyignored=1 ;;
    --copy-untracked) copyuntracked=1 ;;
    --copy-modified) copymodified=1 ;;
    -f | --force) force=1 ;;
    -n | --dry-run) dryrun=1 ;;
    --)
      shift
      break
      ;;
    --*) die "unknown flag '$1'" ;;
    *)
      if [ -z "$from_branch" ]; then
        from_branch="$1"
      elif [ -z "$to_branch" ]; then
        to_branch="$1"
      else
        die "unexpected argument '$1'"
      fi
      ;;
    esac
    shift
  done
  for arg in "$@"; do
    if [ -z "$from_branch" ]; then
      from_branch="$arg"
    elif [ -z "$to_branch" ]; then
      to_branch="$arg"
    else
      die "unexpected argument '$arg'"
    fi
  done
  if [ -n "$from_branch" ] && [ -z "$to_branch" ]; then
    die "missing destination branch"
  fi
  if [ -z "$from_branch" ] && [ -n "$to_branch" ]; then
    die "missing source branch"
  fi
  require_repo
  if [ "$copyignored" -eq 0 ] && [ "$copyuntracked" -eq 0 ] && [ "$copymodified" -eq 0 ] && [ "$copytracked" -eq 0 ]; then
    die "missing copy flag"
  fi
  local root src dst
  root=$(main_worktree_path)
  if [ -z "$from_branch" ] && repo_is_bare; then
    require_not_bare_for_copy
  fi
  if [ -z "$from_branch" ]; then
    src="$root"
    dst=$(git rev-parse --show-toplevel)
    find_worktree_by_path "$root" "$dst" >/dev/null || die "current directory is not a worktree"
  else
    if ! src=$(find_worktree_by_branch "$root" "$from_branch"); then
      die "workspace not found: '$from_branch'"
    fi
    if ! dst=$(find_worktree_by_branch "$root" "$to_branch"); then
      die "workspace not found: '$to_branch'"
    fi
  fi
  if repo_is_bare && { [ "$src" = "$root" ] || [ "$dst" = "$root" ]; }; then
    require_not_bare_for_copy
  fi
  if [ "$src" = "$dst" ]; then
    die "source and destination are the same"
  fi
  copy_files_between "$src" "$dst" "$copyignored" "$copyuntracked" "$copymodified" "$copytracked" "$force" "$dryrun"
}

cmd_ls() {
  local plain=0 json=0
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -h | --help)
      ls_usage
      exit 0
      ;;
    --plain) plain=1 ;;
    --json) json=1 ;;
    --*) die "unknown flag '$1'" ;;
    *) die "unexpected argument '$1'" ;;
    esac
    shift
  done
  require_repo
  local root base
  root=$(main_worktree_path)
  if [ "$plain" -eq 1 ] && [ "$json" -eq 1 ]; then
    die "cannot use --plain and --json together"
  fi
  local mode="table"
  if [ "$plain" -eq 1 ]; then
    mode="plain"
  elif [ "$json" -eq 1 ]; then
    mode="json"
  elif [ ! -t 1 ]; then
    mode="plain"
  fi
  local entries
  entries=$(worktree_entries "$root")
  local filtered=""
  if [ -n "$BASE_DIR_OVERRIDE" ]; then
    base=$(base_dir "$root" "$BASE_DIR_OVERRIDE")
    while IFS= read -r entry; do
      [ -n "$entry" ] || continue
      local path head branch is_bare
      parse_worktree_entry "$entry"
      if [ "$is_bare" = "1" ]; then
        filtered+="(bare)\t$path\t$head\t1\n"
        continue
      fi
      case "$path" in
      "$base"/*)
        filtered+="$branch\t$path\t$head\t0\n"
        ;;
      esac
    done <<<"$entries"
  else
    while IFS= read -r entry; do
      [ -n "$entry" ] || continue
      local path head branch is_bare
      parse_worktree_entry "$entry"
      if [ "$is_bare" = "1" ]; then
        branch="(bare)"
      fi
      filtered+="$branch\t$path\t$head\t$is_bare\n"
    done <<<"$entries"
  fi
  case "$mode" in
  json)
    printf '['
    local first=1
    while IFS= read -r line || [ -n "$line" ]; do
      [ -n "$line" ] || continue
      local branch path head rest is_bare is_bare_json
      branch=${line%%$'\t'*}
      rest=${line#*$'\t'}
      path=${rest%%$'\t'*}
      rest=${rest#*$'\t'}
      head=${rest%%$'\t'*}
      is_bare=${rest#*$'\t'}
      if [ "$is_bare" = "1" ]; then
        is_bare_json="true"
      else
        is_bare_json="false"
      fi
      if [ "$first" -eq 0 ]; then
        printf ','
      fi
      first=0
      printf '{"branch":"%s","path":"%s","head":"%s","is_bare":%s}' "$(json_escape "$branch")" "$(json_escape "$path")" "$(json_escape "$head")" "$is_bare_json"
    done <<<"$(printf '%b' "$filtered")"
    printf ']\n'
    ;;
  plain)
    printf '%b' "$filtered" | awk -F'\t' 'NF>=2 {print $1"\t"$2}'
    ;;
  table)
    printf '%b' "$filtered" | awk -F'\t' 'NF>=3 {printf "%-30s %-60s %s\n", $1, $2, $3}'
    ;;
  esac
}

cmd_rm() {
  local force=0 branch=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -h | --help)
      rm_usage
      exit 0
      ;;
    -f | --force) force=1 ;;
    --*) die "unknown flag '$1'" ;;
    *) if [ -z "$branch" ]; then branch="$1"; else die "unexpected argument '$1'"; fi ;;
    esac
    shift
  done
  [ -n "$branch" ] || die "missing branch"
  require_repo
  local root path
  root=$(main_worktree_path)
  if ! path=$(find_worktree_by_branch "$root" "$branch"); then
    if [ "$force" -eq 1 ]; then
      exit 0
    fi
    die "workspace not found: '$branch'"
  fi
  if [ "$path" = "$root" ]; then
    die "cannot remove main worktree"
  fi
  if [ "$force" -eq 0 ]; then
    local dirty
    dirty=$(git -C "$path" status --porcelain)
    if [ -n "$dirty" ]; then
      if [ -t 0 ]; then
        printf "workspace '%s' has uncommitted changes. remove anyway? [y/N] " "$branch" >&2
        read -r answer
        case "$answer" in
        y | Y | yes | YES) force=1 ;;
        *) exit 1 ;;
        esac
      else
        die "workspace dirty: '$branch'"
      fi
    fi
  fi
  if [ "$force" -eq 1 ]; then
    git -C "$root" worktree remove --force "$path" 2>/dev/null || true
    command rm -rf "$path" 2>/dev/null || true
  else
    git -C "$root" worktree remove "$path"
  fi
  if [ "$force" -eq 1 ]; then
    git -C "$root" branch -D "$branch" 2>/dev/null || true
  else
    git -C "$root" branch -d "$branch"
  fi
  printf '%s\n' "$path"
}

cmd_here() {
  require_repo
  local root base current
  root=$(main_worktree_path)
  base=$(base_dir "$root" "$BASE_DIR_OVERRIDE")
  current=$(git rev-parse --show-toplevel)
  case "$current" in
  "$base"/*) ;;
  *) exit 1 ;;
  esac
  local entry
  while IFS= read -r entry; do
    local path head branch is_bare
    parse_worktree_entry "$entry"
    if [ "$path" = "$current" ]; then
      if [ -n "$branch" ]; then
        printf '%s\n' "$branch"
        exit 0
      fi
    fi
  done < <(worktree_entries "$root")
  exit 1
}

cmd_base() {
  require_repo
  local root base
  root=$(main_worktree_path)
  base=$(base_dir "$root" "$BASE_DIR_OVERRIDE")
  printf '%s\n' "$base"
}

cmd_root() {
  require_repo
  main_worktree_path
}

completion_bash() {
  local commands
  commands="switch sw exec sync ls rm here base root help completion"
  cat <<EOF
command -v wt >/dev/null 2>&1 || return 0

wt() {
  case "\$1" in
    switch|sw)
      local i
      for i in "\$@"; do
        case "\$i" in
          -h|--help)
            command wt "\$@"
            return \$?
            ;;
        esac
      done
      local out path
      out=\$(command wt "\$@")
      local rc=\$?
      path=\$(printf '%s\n' "\$out" | tail -n 1)
      if [[ \$rc -eq 0 && -n "\$path" && -d "\$path" ]]; then
        if [[ "\$out" != "\$path" ]]; then
          printf '%s\n' "\$out" | sed '\$d'
        fi
        cd "\$path"
      else
        [[ -n "\$out" ]] && printf '%s\n' "\$out"
        return \$rc
      fi
      ;;
    *)
      command wt "\$@"
      ;;
  esac
}

__wt_branches() {
  git rev-parse --git-dir >/dev/null 2>&1 || return 0
  git for-each-ref --format='%(refname:short)' refs/heads 2>/dev/null
}

_wt_complete() {
  local cur prev cmd
  cur="\${COMP_WORDS[COMP_CWORD]}"
  prev="\${COMP_WORDS[COMP_CWORD-1]}"
  cmd=""
  compopt +o default +o bashdefault 2>/dev/null
  local commands="$commands"
  local flags=""
  local i
  local global_flags="--base-dir -h --help"
  for i in "\${COMP_WORDS[@]}"; do
    if [ "\$i" = "--" ]; then
      return 0
    fi
  done
  if [ "\$prev" = "--base-dir" ]; then
    return 0
  fi
  i=1
  while [ "\$i" -lt "\$COMP_CWORD" ]; do
    local word="\${COMP_WORDS[\$i]}"
    case "\$word" in
      --base-dir)
        i=\$((i + 2))
        ;;
      --base-dir=*)
        i=\$((i + 1))
        ;;
      -h|--help)
        i=\$((i + 1))
        ;;
      --*)
        i=\$((i + 1))
        ;;
      *)
        cmd="\$word"
        break
        ;;
    esac
  done
  if [ -z "\$cmd" ]; then
    COMPREPLY=( \$(compgen -W "\$global_flags \$commands" -- "\$cur") )
    return 0
  fi
  case "\$cmd" in
    switch|sw)
      flags="--from --path --fetch --init-submodules --copy-all --copy-ignored --copy-untracked --copy-modified -h --help"
      case "\$prev" in
        --from|--path) return 0 ;;
      esac
      COMPREPLY=( \$(compgen -W "\$flags \$(__wt_branches)" -- "\$cur") )
      ;;
    exec)
      flags="--from --path --fetch -h --help --"
      case "\$prev" in
        --from|--path|--) return 0 ;;
      esac
      if [ "\$COMP_CWORD" -eq 2 ]; then
        COMPREPLY=( \$(compgen -W "\$(__wt_branches)" -- "\$cur") )
      else
        COMPREPLY=( \$(compgen -W "\$flags" -- "\$cur") )
      fi
      ;;
    sync)
      flags="--copy-all --copy-ignored --copy-untracked --copy-modified -f --force -n --dry-run -h --help"
      COMPREPLY=( \$(compgen -W "\$flags \$(__wt_branches)" -- "\$cur") )
      ;;
    rm)
      flags="-f --force -h --help"
      COMPREPLY=( \$(compgen -W "\$flags \$(__wt_branches)" -- "\$cur") )
      ;;
    ls)
      flags="--plain --json -h --help"
      COMPREPLY=( \$(compgen -W "\$flags" -- "\$cur") )
      ;;
    here|base|root)
      flags="-h --help"
      COMPREPLY=( \$(compgen -W "\$flags" -- "\$cur") )
      ;;
    help)
      flags="switch sw exec sync ls rm here base root help completion"
      COMPREPLY=( \$(compgen -W "\$flags" -- "\$cur") )
      ;;
    completion)
      flags="bash zsh fish"
      COMPREPLY=( \$(compgen -W "\$flags" -- "\$cur") )
      ;;
  esac
}

complete -F _wt_complete wt
EOF
}

completion_zsh() {
  cat <<EOF
command -v wt >/dev/null 2>&1 || return 0

wt() {
  case "\$1" in
    switch|sw)
      local i
      for i in "\$@"; do
        case "\$i" in
          -h|--help)
            command wt "\$@"
            return \$?
            ;;
        esac
      done
      local out path
      out=\$(command wt "\$@")
      local rc=\$?
      path=\$(printf '%s\n' "\$out" | tail -n 1)
      if [[ \$rc -eq 0 && -n "\$path" && -d "\$path" ]]; then
        if [[ "\$out" != "\$path" ]]; then
          printf '%s\n' "\$out" | sed '\$d'
        fi
        cd "\$path"
      else
        [[ -n "\$out" ]] && printf '%s\n' "\$out"
        return \$rc
      fi
      ;;
    *)
      command wt "\$@"
      ;;
  esac
}

__wt_branches() {
  git rev-parse --git-dir >/dev/null 2>&1 || return 0
  git for-each-ref --format='%(refname:short)' refs/heads 2>/dev/null
}

_wt() {
  local -a subcmds subdescs switch_flags switch_descs exec_flags exec_descs sync_flags sync_descs ls_flags ls_descs rm_flags rm_descs hb_flags hb_descs global_flags global_descs
  subcmds=(switch sw exec sync ls rm here base root help completion)
  subdescs=(
    "create or open a workspace"
    "alias for switch"
    "open a workspace and run a command"
    "copy files between worktrees"
    "list workspaces"
    "remove a workspace"
    "print current workspace branch"
    "print base dir"
    "print main worktree path"
    "show help"
    "print shell completion"
  )
  global_flags=(--base-dir -h --help)
  global_descs=("base dir override" "show help" "show help")
  switch_flags=(--from --path --fetch --init-submodules --copy-all --copy-ignored --copy-untracked --copy-modified -h --help)
  switch_descs=("base ref for new branch" "explicit worktree path" "fetch remotes before resolving --from" "initialize submodules in new worktree" "copy all files to new worktree" "copy gitignored files to new worktree" "copy untracked files to new worktree" "copy modified files to new worktree" "show help" "show help")
  exec_flags=(--from --path --fetch -h --help --)
  exec_descs=("base ref for new branch" "explicit worktree path" "fetch remotes before resolving --from" "show help" "show help" "end of flags")
  sync_flags=(--copy-all --copy-ignored --copy-untracked --copy-modified -f --force -n --dry-run -h --help)
  sync_descs=("copy all files" "copy gitignored files" "copy untracked files" "copy modified files" "overwrite conflicting destination files" "overwrite conflicting destination files" "show files that would be copied" "show files that would be copied" "show help" "show help")
  ls_flags=(--plain --json -h --help)
  ls_descs=("tab-delimited output" "JSON output" "show help" "show help")
  rm_flags=(-f --force -h --help)
  rm_descs=("remove even if dirty" "remove even if dirty" "show help" "show help")
  hb_flags=(-h --help)
  hb_descs=("show help" "show help")
  if (( CURRENT == 2 )); then
    compadd -d global_descs -- \$global_flags
    compadd -d subdescs -- \$subcmds
    return 0
  fi
  local cmd=""
  local idx=2
  while (( idx <= CURRENT )); do
    local word=\${words[idx]}
    case "\$word" in
      --base-dir)
        idx=\$((idx + 2))
        ;;
      --base-dir=*)
        idx=\$((idx + 1))
        ;;
      -h|--help)
        idx=\$((idx + 1))
        ;;
      --*)
        idx=\$((idx + 1))
        ;;
      *)
        cmd=\$word
        break
        ;;
    esac
  done
  if [[ "\${words[CURRENT-1]}" == --base-dir ]]; then
    return 0
  fi
  if [[ -z "\$cmd" ]]; then
    compadd -d global_descs -- \$global_flags
    compadd -d subdescs -- \$subcmds
    return 0
  fi
  case "\$cmd" in
    switch|sw)
      if [[ "\${words[CURRENT-1]}" == --from || "\${words[CURRENT-1]}" == --path ]]; then
        return 0
      fi
      compadd -d switch_descs -- \$switch_flags
      compadd -- \${(f)"\$(__wt_branches)"}
      return 0
      ;;
    exec)
      if [[ "\${words[CURRENT-1]}" == --from || "\${words[CURRENT-1]}" == --path || "\${words[CURRENT-1]}" == -- ]]; then
        return 0
      fi
      if (( CURRENT == 3 )); then
        compadd -- \${(f)"\$(__wt_branches)"}
      else
        compadd -d exec_descs -- \$exec_flags
      fi
      return 0
      ;;
    sync)
      compadd -d sync_descs -- \$sync_flags
      compadd -- \${(f)"\$(__wt_branches)"}
      return 0
      ;;
    rm)
      compadd -d rm_descs -- \$rm_flags
      compadd -- \${(f)"\$(__wt_branches)"}
      return 0
      ;;
    ls)
      compadd -d ls_descs -- \$ls_flags
      return 0
      ;;
    here|base|root)
      compadd -d hb_descs -- \$hb_flags
      return 0
      ;;
    help)
      compadd -d subdescs -- \$subcmds
      return 0
      ;;
    completion)
      compadd -- bash zsh fish
      return 0
      ;;
  esac
  return 0
}

compdef _wt wt
EOF
}

completion_fish() {
  cat <<'EOF'
type -q wt; or return

function wt
  if test "$argv[1]" = "switch" -o "$argv[1]" = "sw"
    if contains -- -h $argv; or contains -- --help $argv
      command wt $argv
      return $status
    end
    set -g __wt_rc 0
    set -l out (begin
      command wt $argv
      set -g __wt_rc $status
    end | string collect | string trim --right)
    set -l rc $__wt_rc
    set -e __wt_rc
    set -l out_lines (string split -- "\n" $out)
    set -l path $out_lines[-1]
    if test $rc -eq 0 -a -n "$path" -a -d "$path"
      if test (count $out_lines) -gt 1
        printf '%s\n' $out_lines[1..-2]
      end
      cd "$path"
    else
      test -n "$out"; and printf '%s\n' "$out"
      return $rc
    end
  else
    command wt $argv
  end
end

function __wt_branches
  command git rev-parse --git-dir >/dev/null 2>&1
  or return
  command git for-each-ref --format='%(refname:short)' refs/heads 2>/dev/null
end

complete -c wt -f
complete -c wt -l base-dir -r -d 'base dir override'
complete -c wt -s h -l help -d 'show help'
complete -c wt -n '__fish_use_subcommand' -a switch -d 'create or open a workspace'
complete -c wt -n '__fish_use_subcommand' -a sw -d 'alias for switch'
complete -c wt -n '__fish_use_subcommand' -a exec -d 'open a workspace and run a command'
complete -c wt -n '__fish_use_subcommand' -a sync -d 'copy files between worktrees'
complete -c wt -n '__fish_use_subcommand' -a ls -d 'list workspaces'
complete -c wt -n '__fish_use_subcommand' -a rm -d 'remove a workspace'
complete -c wt -n '__fish_use_subcommand' -a here -d 'print current workspace branch'
complete -c wt -n '__fish_use_subcommand' -a base -d 'print base dir'
complete -c wt -n '__fish_use_subcommand' -a root -d 'print main worktree path'
complete -c wt -n '__fish_use_subcommand' -a help -d 'show help'
complete -c wt -n '__fish_use_subcommand' -a completion -d 'print shell completion'
complete -c wt -n '__fish_seen_subcommand_from switch sw exec sync rm' -a '(__wt_branches)'

complete -c wt -n '__fish_seen_subcommand_from switch sw exec' -l from -r -d 'base ref for new branch'
complete -c wt -n '__fish_seen_subcommand_from switch sw exec' -l path -r -d 'explicit worktree path'
complete -c wt -n '__fish_seen_subcommand_from switch sw exec' -l fetch -d 'fetch remotes before resolving --from'
complete -c wt -n '__fish_seen_subcommand_from switch sw exec' -s h -l help -d 'show help'
complete -c wt -n '__fish_seen_subcommand_from switch sw' -l init-submodules -d 'initialize submodules in new worktree'
complete -c wt -n '__fish_seen_subcommand_from switch sw' -l copy-all -d 'copy all files to new worktree'
complete -c wt -n '__fish_seen_subcommand_from switch sw' -l copy-ignored -d 'copy gitignored files to new worktree'
complete -c wt -n '__fish_seen_subcommand_from switch sw' -l copy-untracked -d 'copy untracked files to new worktree'
complete -c wt -n '__fish_seen_subcommand_from switch sw' -l copy-modified -d 'copy modified files to new worktree'
complete -c wt -n '__fish_seen_subcommand_from sync' -l copy-all -d 'copy all files'
complete -c wt -n '__fish_seen_subcommand_from sync' -l copy-ignored -d 'copy gitignored files'
complete -c wt -n '__fish_seen_subcommand_from sync' -l copy-untracked -d 'copy untracked files'
complete -c wt -n '__fish_seen_subcommand_from sync' -l copy-modified -d 'copy modified files'
complete -c wt -n '__fish_seen_subcommand_from sync' -s f -l force -d 'overwrite conflicting destination files'
complete -c wt -n '__fish_seen_subcommand_from sync' -s n -l dry-run -d 'show files that would be copied'
complete -c wt -n '__fish_seen_subcommand_from sync' -s h -l help -d 'show help'

complete -c wt -n '__fish_seen_subcommand_from ls' -l plain -d 'tab-delimited output'
complete -c wt -n '__fish_seen_subcommand_from ls' -l json -d 'JSON output'
complete -c wt -n '__fish_seen_subcommand_from ls' -s h -l help -d 'show help'

complete -c wt -n '__fish_seen_subcommand_from rm' -s f -l force -d 'remove even if dirty'
complete -c wt -n '__fish_seen_subcommand_from rm' -s h -l help -d 'show help'

complete -c wt -n '__fish_seen_subcommand_from help' -a switch -d 'create or open a workspace'
complete -c wt -n '__fish_seen_subcommand_from help' -a sw -d 'alias for switch'
complete -c wt -n '__fish_seen_subcommand_from help' -a exec -d 'open a workspace and run a command'
complete -c wt -n '__fish_seen_subcommand_from help' -a sync -d 'copy files between worktrees'
complete -c wt -n '__fish_seen_subcommand_from help' -a ls -d 'list workspaces'
complete -c wt -n '__fish_seen_subcommand_from help' -a rm -d 'remove a workspace'
complete -c wt -n '__fish_seen_subcommand_from help' -a here -d 'print current workspace branch'
complete -c wt -n '__fish_seen_subcommand_from help' -a base -d 'print base dir'
complete -c wt -n '__fish_seen_subcommand_from help' -a root -d 'print main worktree path'
complete -c wt -n '__fish_seen_subcommand_from help' -a help -d 'show help'
complete -c wt -n '__fish_seen_subcommand_from help' -a completion -d 'print shell completion'
complete -c wt -n '__fish_seen_subcommand_from completion' -a 'bash zsh fish'
EOF
}

cmd_completion() {
  if [ "$#" -eq 0 ]; then
    completion_usage
    exit 1
  fi
  case "$1" in
    bash) completion_bash ;;
    zsh) completion_zsh ;;
    fish) completion_fish ;;
    *) die "unknown shell '$1'" ;;
  esac
}

cmd_help() {
  if [ "$#" -eq 0 ]; then
    usage
    exit 0
  fi
  case "$1" in
  switch | sw) switch_usage ;;
  exec) exec_usage ;;
  sync) sync_usage ;;
  ls) ls_usage ;;
  rm) rm_usage ;;
  here) here_usage ;;
  base) base_usage ;;
  root) root_usage ;;
  completion) completion_usage ;;
  help) usage ;;
  *) die "unknown command '$1'" ;;
  esac
}

while [ "$#" -gt 0 ]; do
  case "$1" in
  --base-dir)
    [ -n "${2:-}" ] || die "missing value for --base-dir"
    BASE_DIR_OVERRIDE="$2"
    shift 2
    ;;
  --base-dir=*)
    BASE_DIR_OVERRIDE="${1#--base-dir=}"
    shift
    ;;
  -h | --help)
    break
    ;;
  --*) die "unknown flag '$1'" ;;
  *) break ;;
  esac
done

case "${1:-}" in
"")
  usage
  exit 1
  ;;
-h | --help)
  usage
  exit 0
  ;;
help)
  shift
  cmd_help "$@"
  ;;
switch)
  shift
  cmd_switch "$@"
  ;;
sw)
  shift
  cmd_switch "$@"
  ;;
exec)
  shift
  cmd_exec "$@"
  ;;
sync)
  shift
  cmd_sync "$@"
  ;;
ls)
  shift
  cmd_ls "$@"
  ;;
rm)
  shift
  cmd_rm "$@"
  ;;
here)
  shift
  cmd_here "$@"
  ;;
base)
  shift
  cmd_base "$@"
  ;;
root)
  shift
  cmd_root "$@"
  ;;
completion)
  shift
  cmd_completion "$@"
  ;;
*) die "unknown command '$1'" ;;
esac
